<svg xmlns    = "http://www.w3.org/2000/svg"
     id       = "Hintergrund"
     width    = "0"
     height   = "0"
     viewBox  = "0 0 0 0">
  <style>
    #Hintergrund {background-color: #000000;}
       
    .Segmente {
      stroke:           #7f7f7f;
      stroke-width:     1;
      stroke-opacity:   0.618;
      stroke-linecap:   round;
      stroke-dasharray: 1, 1.62;
    }
  </style>
  <script type="text/javascript">
  <![CDATA[
    var X_Versatz       = 3.5;
    var Y_Versatz       = 3.0;
    var Streckfaktor    = window.devicePixelRatio;
    var Segmentlänge    = (1 + 4 * (1.62 + 1)) * Streckfaktor;
    var Spaltenbreite   = Segmentlänge * Math.cos(Math.PI / 6);
    var Zeilenhöhe      = Segmentlänge * 1.5;
    var AbstandslückeS  = (8 - 4 * Math.sqrt(3)) * Streckfaktor;
    var AbstandslückeDX = AbstandslückeS * Math.cos(Math.PI / 6);
    var AbstandslückeDY = AbstandslückeS * Math.sin(Math.PI / 6);

    var Zeilenanzahl    = 0;
    var Spaltenanzahl   = 0;
    var Fensterhöhe     = 0;
    var Fensterbreite   = 0;

    var X_Rasterindexgrenze      = 0;
    var Y_Rasterindexgrenze      = 0;
    var Anzeigenbereichsänderung = 1;

    var Hintergrund = document.getElementById("Hintergrund");
    //Hintergrund.setAttribute("width", window.innerWidth);
    //Hintergrund.setAttribute("height", window.innerHeight);
    //Hintergrund.setAttribute("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight);



    async function Warte(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }



    async function S_SegmentErstellen(Z, S) {
      var NeueLinie = document.createElementNS("http://www.w3.org/2000/svg", "line");
      NeueLinie.setAttributeNS(null, "id", "L" + Z + "_" + S + "_1");
      NeueLinie.setAttributeNS(null, "class", "Segmente");
      NeueLinie.setAttributeNS(null, "x1", X_Versatz + S * Spaltenbreite);
      NeueLinie.setAttributeNS(null, "x2", X_Versatz + S * Spaltenbreite);
      if ((Z % 2 == 1 && S % 2 == 0) || (Z % 2 == 0 && S % 2 == 1)) {
        NeueLinie.setAttributeNS(null, "y1", Y_Versatz + Z * Zeilenhöhe + AbstandslückeS - Segmentlänge);
        NeueLinie.setAttributeNS(null, "y2", Y_Versatz + Z * Zeilenhöhe - AbstandslückeS);
      } else {
        NeueLinie.setAttributeNS(null, "y1", Y_Versatz + (Z - 1) * Zeilenhöhe + AbstandslückeS);
        NeueLinie.setAttributeNS(null, "y2", Y_Versatz + (Z - 1) * Zeilenhöhe - AbstandslückeS + Segmentlänge);
      }

      Hintergrund.appendChild(NeueLinie);
    }



    async function D_SegmenteErstellen(Z, S) {
      var NeueLinie1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
      NeueLinie1.setAttributeNS(null, "id", "L" + Z + "_" + S + "_0");
      NeueLinie1.setAttributeNS(null, "class", "Segmente");
      NeueLinie1.setAttributeNS(null, "x1", X_Versatz + AbstandslückeDX + Spaltenbreite * (S - 1));
      NeueLinie1.setAttributeNS(null, "x2", X_Versatz - AbstandslückeDX + Spaltenbreite * S);
      if ((Z % 2 == 1 && S % 2 == 1) || (Z % 2 == 0 && S % 2 == 0)) {
        NeueLinie1.setAttributeNS(null, "y1", Y_Versatz - AbstandslückeDY + Zeilenhöhe * Z - Segmentlänge);
        NeueLinie1.setAttributeNS(null, "y2", Y_Versatz + AbstandslückeDY + Zeilenhöhe * (Z - 1));
      } else {
        NeueLinie1.setAttributeNS(null, "y1", Y_Versatz + AbstandslückeDY + Zeilenhöhe * (Z - 1));
        NeueLinie1.setAttributeNS(null, "y2", Y_Versatz - AbstandslückeDY + Zeilenhöhe * Z - Segmentlänge);
      }
      Hintergrund.appendChild(NeueLinie1);
      
      var NeueLinie2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
      NeueLinie2.setAttributeNS(null, "id", "L" + Z + "_" + S + "_2");
      NeueLinie2.setAttributeNS(null, "class", "Segmente");
      NeueLinie2.setAttributeNS(null, "x1", X_Versatz + AbstandslückeDX + Spaltenbreite * (S - 1));
      NeueLinie2.setAttributeNS(null, "x2", X_Versatz - AbstandslückeDX + Spaltenbreite * S);
      if ((Z % 2 == 1 && S % 2 == 1) || (Z % 2 == 0 && S % 2 == 0)) {
        NeueLinie2.setAttributeNS(null, "y1", Y_Versatz - AbstandslückeDY + Zeilenhöhe * Z);
        NeueLinie2.setAttributeNS(null, "y2", Y_Versatz + AbstandslückeDY + Zeilenhöhe * (Z - 1) + Segmentlänge);
      } else {
        NeueLinie2.setAttributeNS(null, "y1", Y_Versatz + AbstandslückeDY + Zeilenhöhe * (Z - 1) + Segmentlänge);
        NeueLinie2.setAttributeNS(null, "y2", Y_Versatz - AbstandslückeDY + Zeilenhöhe * Z);
      }
      Hintergrund.appendChild(NeueLinie2);
    }
    


    async function RasterAuffüllen() {
      // console.log("RasterAuffüllen");
      if (Zeilenanzahl < Y_Rasterindexgrenze) {
        for (let Z = Zeilenanzahl + 1; Z <= Y_Rasterindexgrenze; Z++) {
          // Erzeuge erstes Strichlein…
          await S_SegmentErstellen(Z, 0);
          for (let S = 1; S <= Spaltenanzahl; S++) {
            // Die drei Liniensgemente erstellen…
            await S_SegmentErstellen(Z, S);
            await D_SegmenteErstellen(Z, S);
          }
        }
      }

      if (Spaltenanzahl < X_Rasterindexgrenze) {
        for (let Z = 1; Z <= Y_Rasterindexgrenze; Z++) {
          for (let S = Spaltenanzahl + 1; S <= X_Rasterindexgrenze; S++) {
            // Die drei Liniensegmente erstellen…
            await S_SegmentErstellen(Z, S);
            await D_SegmenteErstellen(Z, S);
          }
        }
      } 

      Zeilenanzahl  = Y_Rasterindexgrenze;
      Spaltenanzahl = X_Rasterindexgrenze;     
    }



    async function AnzeigenbereichAnFensterAnpassen() {
      // console.log("AnzeigenbereichAnFensterAnpassen");
      // Raster auffüllen, falls die Fensterbreite die Rasterbreite oder die Fensterhöhe die Rasterhöhe überschreitet
      // Anzeigebereich einschränken, wenn der Fensterbereich kleiner als der Anzeigebereich wird
      X_Rasterindexgrenze = parseInt(Math.floor((window.innerWidth - X_Versatz) / Spaltenbreite));
      Y_Rasterindexgrenze = parseInt(Math.floor((window.innerHeight - Y_Versatz) / Zeilenhöhe));

      if (Y_Rasterindexgrenze > Zeilenanzahl ||
          X_Rasterindexgrenze > Spaltenanzahl)
        await RasterAuffüllen();
    }



    async function AnzeigenbereichNeuBestimmen() {
      // console.log("AnzeigenbereichNeuBestimmen");
      Hintergrund.setAttribute("width", window.innerWidth);
      Hintergrund.setAttribute("height", window.innerHeight);
      Hintergrund.setAttribute("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight);
      Anzeigenbereichsänderung = 1;
    }
    AnzeigenbereichNeuBestimmen();
    window.addEventListener("resize", AnzeigenbereichNeuBestimmen);



    async function Hintergrundanimation () {
      // console.log("Hintergrundanimation");
      await Warte(100);
      var RGB_R = "7F";
      var RGB_G = "7F";
      var RGB_B = "7F";Z_Index
      var Z_Index = 1;
      var S_Index = 1;
      var Segment = 0;
      var Linie;

      while (true) {
        if (Anzeigenbereichsänderung == 1) {
          await AnzeigenbereichAnFensterAnpassen();
          Anzeigenbereichsänderung = 0;
        }

        RGB_R = parseInt(Math.ceil(128 + Math.random() * 96)).toString(16).padStart(2, "0");
        RGB_G = parseInt(Math.ceil(112 + Math.random() * 80)).toString(16).padStart(2, "0");
        RGB_B = parseInt(Math.ceil( 96 + Math.random() * 48)).toString(16).padStart(2, "0");

        Z_Index = parseInt(Math.ceil(0.1 + Math.random() * (Zeilenanzahl - 0.1)));
        S_Index = parseInt(Math.ceil(0.1 + Math.random() * (Spaltenanzahl -0.1)));
        Segment = parseInt(Math.floor(Math.random() * 3));
        Linie = document.getElementById("L" + Z_Index + "_" + S_Index + "_" + Segment);
        if (Linie !== null) {
          Linie.style.stroke = "#" + RGB_R + RGB_G + RGB_B;
          // Linie.style.strokeOpacity = 0.618;
          // Linie.style.strokeWidth = 1;
        } else {
          console.log ("L" + Z_Index + "_" + S_Index + "_" + Segment + " - " + Zeilenanzahl + " " + Spaltenanzahl);  
        }

        await Warte(100);
      }
    }
    Hintergrundanimation();
  ]]>
  </script>
</svg>
